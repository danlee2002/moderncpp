### Introduction:
Consider the following snippet of code.
```cpp
int add(int a, int b) {
    return a + b;
}
int main() {
    int result = add(1,2);
    return 0;
}
```
It's clear, that the following piece of code adds two integers and performs these operation in runtime.
What if we instead perform a one time calculation and preprocess so that it's not performed at runtime.
That where the `constexpr` keyword comes in dandy. Note that any value assigned with constexpr is immutable by nature. 
```cpp
constexpr int add(int a, int b) {
    return a + b;
}
int main() {
    constexpr int result = add(1,2);
    return 0;
}
```
Now consider the following asm generated by the first example:
```asm
call    sum(int, int)
```
As one can see we defined a subroutine to perform addition.
Now consider the asm code generated by adding constexpr.
The part that handles addition can be found here.
```asm
movl    $5, -8(%rbp)
```
Rather than peforming a subroutine to add. We simply load the value to the approriate location.
### constexpr if 
We shall now talk about feature introduced in `c++17` the `if constexpr` statement.
If one is aware of how if statements work, it is clear that a sequence of if statments can be though of as a sequence of branch statements.
Rather than simply evaluating every branch statement at runtime, we can simply jump to the location in memory if we preprocess during compile time.
```cpp
template<typename T> 
auto get_value(T t) {
if constexpr(std::is_pointer_v<T>)  {
    return *t;
} else {
    return t;
}
}
```

